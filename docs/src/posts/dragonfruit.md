---
icon: edit
date: 2022-01-10
category:
  - Language
  - MySQL
tag:
  - red
  - big
---

# MySQL笔记

## MySQL常用面试题

1、MySQL 中有哪几种锁？  
1、表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度也最高。  
2、行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。  
3、页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。

2、MySQL中InnoDB支持的四种事务隔离级别名称，以及逐级之间的区别
SQL标准定义的四个隔离级别为：  
1、read uncommited: 读取未提交数据  
2、read committed：脏读，不可重复读  
3、repeatable read：可重读  
4、serializable：串行事物  

3、主键和候选键有什么区别？  
1、表格的每一行都由主键唯一标识,一个表只有一个主键。  
2、主键也是候选键。按照惯例，候选键可以被指定为主键，并且可以用于任何外键
引用。    

4、MySQL 如何优化 DISTINCT？  
DISTINCT 在所有列上转换为 GROUP BY，并与 ORDER BY 子句结合使用。
SELECT DISTINCT t1.a FROM t1,t2 where t1.a=t2.a;  

5、NOW（）和 CURRENT_DATE（）有什么区别？  
NOW（）命令用于显示当前年份，月份，日期，小时，分钟和秒。
CURRENT_DATE（）仅显示当前年份，月份和日期。  

6、MySQL 支持事务吗？  
在缺省模式下，MySQL 是 autocommit 模式的，所有的数据库更新操作都会即时
提交，所以在缺省情况下，MySQL 是不支持事务的。
但是如果你的 MySQL 表类型是使用 InnoDB Tables 或 BDB tables 的话，你的
MySQL 就可以使用事务处理,使用 SET AUTOCOMMIT=0 就可以使 MySQL 允许在非 autocommit 模式，在非autocommit 模式下，你必须使用 COMMIT 来提交你的更改，或者用 ROLLBACK来回滚你的更改。  

7、锁的优化策略？  
1、读写分离  
2、分段加锁  
3、减少锁持有的时间  
4.多个线程尽量以相同的顺序去获取资源不能将锁的粒度过于细化，不然可能会出现线程的加锁和释放次数过多，反而效率不如一次加一把大锁。  

8、实践中如何优化 MySQL？  
1、SQL 语句及索引的优化
2、数据库表结构的优化
3、系统配置的优化
4、硬件的优化  

9、优化数据库的方法？  
1、选取最适用的字段属性，尽可能减少定义字段宽度，尽量把字段设置 NOTNULL，例如’省份’、’性别’最好适用 ENUM  
2、使用连接(JOIN)来代替子查询
3、适用联合(UNION)来代替手动创建的临时表
4、事务处理
5、锁定表、优化事务处理
6、适用外键，优化锁定表
7、建立索引
8、优化查询语句  

10、为表中得字段选择合适得数据类型？   
字段类型优先级: 整形>date,time>enum,char>varchar>blob,text
优先考虑数字类型，其次是日期或者二进制类型，最后是字符串类型，同级别得数据类型，应该优先选择占用空间小的数据类型  

11、解释 MySQL 外连接、内连接与自连接的区别？  
先说什么是交叉连接: 交叉连接又叫笛卡尔积，它是指不使用任何条件，直接将一个表的所有记录和另一个表中的所有记录一一匹配。  
内连接 则是只有条件的交叉连接，根据某个条件筛选出符合条件的记录，不符合条件的记录不会出现在结果集中，即内连接只连接匹配的行。  
外连接 其结果集中不仅包含符合连接条件的行，而且还会包括左表、右表或两个
表中的所有数据行，这三种情况依次称之为左外连接，右外连接，和全外连接。  
左外连接，也称左连接，左表为主表，左表中的所有记录都会出现在结果集中，对于那些在右表中并没有匹配的记录，仍然要显示，右边对应的那些字段值以NULL 来填充。右外连接，也称右连接，右表为主表，右表中的所有记录都会出现在结果集中。左连接和右连接可以互换，MySQL 目前还不支持全外连接。  

12、Myql 中的事务回滚机制概述？  
事务是用户定义的一个数据库操作序列，这些操作要么全做要么全不做，是一个
不可分割的工作单位，事务回滚是指将该事务已经完成的对数据库的更新操作撤销。  
要同时修改数据库中两个不同表时，如果它们不是一个事务的话，当第一个表修改完，可能第二个表修改过程中出现了异常而没能修改，此时就只有第二个表依旧是未修改之前状态，而第一个表已经被修改完毕。而当你把它们设定为一个事务的时候，当第一个表修改完，第二表修改出现异常而没能修改，第一个表和第二个表都要回到未修改的状态，这就是所谓的事务回滚

## 热爱

加油努力
  

