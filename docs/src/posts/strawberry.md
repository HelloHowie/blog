---
icon: edit
date: 2023-06-03
category:
  - Language
  - Java
tag:
  - red
  - small
---

# Java笔记

## Java基础知识

1、线程与进程的区别？  
进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。一个程序至少有一个进程,一个进程至少有一个线程。  

2、什么是多线程中的上下文切换？  
多线程会共同使用一组计算机上的 CPU，而线程数大于给程序分配的 CPU 数量时，为了让各个线程都有执行的机会，就需要轮转使用 CPU。不同的线程切换使用 CPU发生的切换数据等就是上下文切换。  

3、死锁与活锁的区别，死锁与饥饿的区别？  
死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。  
产生死锁的必要条件：
1、互斥条件：所谓互斥就是进程在某一时间内独占资源。
2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3、不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。
4、循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。  
活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。  
饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。  

4、什么是 Callable 和 Future?  
Callable 接口类似于 Runnable，从名字就可以看出来了，但是 Runnable 不会返回结果，并且无法抛出返回结果的异常，而 Callable 功能更强大一些，被线程执行后，可以返回值，这个返回值可以被 Future 拿到，也就是说，Future 可以拿到异步执行任务的返回值。可以认为是带有回调的 Runnable。Future 接口表示异步任务，是还没有完成的任务给出的未来结果。所以说 Callable用于产生结果，Future 用于获取结果。  

5、为什么我们调用 start()方法时会执行 run()方法，为什么我们不能直接调用 run()方法？  
当你调用 start()方法时你将创建新的线程，并且执行在 run()方法里的代码。但是如果你直接调用 run()方法，它不会创建新的线程也不会执行调用线程的代码，只会把 run 方法当作普通方法去执行。  

6、java 中有几种方法可以实现一个线程？  
继承 Thread 类；实现 Runnable 接口；实现 Callable 接口，需要实现的是 call() 方法  

7、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？  
悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。再比如 Java 里面的同步原语 synchronized 关键字的实现也是悲观锁。  
乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于 write_condition 机制，其实都是提供的乐观锁。在 Java中 java.util.concurrent.atomic 包下面的原子变量类就是使用了乐观锁的一种实现方式 CAS 实现的。  

8、什么叫线程安全？servlet 是线程安全吗?  
线程安全是编程中的术语，指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。  
Servlet 不是线程安全的，servlet 是单实例多线程的，当多个线程同时访问同一个方法，是不能保证共享变量的线程安全性的。  
Struts2 的 action 是多实例多线程的，是线程安全的，每个请求过来都会 new 一
个新的 action 分配给这个请求，请求完成后销毁。SpringMVC 的 Controller 是线程安全的吗？不是的，和 Servlet 类似的处理流程。  
Struts2 好处是不用考虑线程安全问题；Servlet 和 SpringMVC 需要考虑线程安全问题，但是性能可以提升不用处理太多的 gc，可以使用 ThreadLocal 来处理多线程的问题。  

9、如何在两个线程间共享数据？  
在两个线程间共享变量即可实现共享。一般来说，共享变量要求变量本身是线程安全的，然后在线程内使用的时候，如果有对共享变量的复合操作，那么也得保证复合操作的线程安全性。  

10、Thread 类中的 yield 方法有什么作用？  
使当前线程从执行状态（运行状态）变为可执行态（就绪状态）。当前线程到了就绪状态，那么接下来哪个线程会从就绪状态变成执行状态呢？可能是当前线程，也可能是其他线程，看系统的分配了。  

11、什么是阻塞式方法？  
阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就回。  

12、可以直接调用 Thread 类的 run ()方法么？  
当然可以。但是如果我们调用了 Thread 的 run()方法，它的行为就会和普通的方法一样，会在当前线程中执行。为了在新的线程中执行我们的代码，必须使用Thread.start()方法。  

13、同步方法和同步块，哪个是更好的选择？  
同步块是更好的选择，因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。同步块更要符合开放调用的原则，只在需要锁住的代码块锁住相应的对象，这样从侧面来说也可以避免死锁。  

14、并发编程三要素？  
1、原子性
原子性指的是一个或者多个操作，要么全部执行并且在执行的过程中不被其他操
作打断，要么就全部都不执行。  
2、可见性
可见性指多个线程操作一个共享变量时，其中一个线程对变量进行修改后，其他
线程可以立即看到修改的结果。  
3、有序性
有序性，即程序的执行顺序按照代码的先后顺序来执行。  

15、四种线程池的创建？  
1、newCachedThreadPool 创建一个可缓存线程池。2、newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数。3、newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。4、newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务。  

16、线程池的优点？  
1、重用存在的线程，减少对象创建销毁的开销。2、可有效的控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免堵塞。3、提供定时执行、定期执行、单线程、并发数控制等功能。  

17、synchronized 的作用？  
在 Java 中，synchronized 关键字是用来控制线程同步的，就是在多线程的环境下，控制 synchronized 代码段不被多个线程同时执行。synchronized 既可以加在一段代码上，也可以加在方法上。  

18、synchronized、volatile、CAS 比较？  
1、synchronized 是悲观锁，属于抢占式，会引起其他线程阻塞。  
2、volatile 提供多线程共享变量可见性和禁止指令重排序优化。  
3、CAS 是基于冲突检测的乐观锁（非阻塞）。  

19、sleep 方法和 wait 方法有什么区别?  
这个问题常问，sleep 方法和 wait 方法都可以用来放弃 CPU 一定的时间，不同点在于如果线程持有某个对象的监视器，sleep 方法不会放弃这个对象的监视器，wait 方法会放弃这个对象的监视器。  

20、多线程同步有哪几种方法？  
Synchronized 关键字，Lock 锁实现，分布式锁等。  

21、Java 死锁以及如何避免？  
Java 中的死锁是一种编程情况，其中两个或多个线程被永久阻塞，Java 死锁情况出现至少两个线程和两个或更多资源。Java 发生死锁的根本原因是：在申请锁时发生了交叉闭环申请。  

22、单例模式的线程安全性？  
老生常谈的问题了，首先要说的是单例模式的线程安全意味着：某个类的实例在多线程环境下只会被创建一次出来。单例模式有很多种的写法，我总结一下：  
1、饿汉式单例模式的写法：线程安全  
2、懒汉式单例模式的写法：非线程安全  
3、双检锁单例模式的写法：线程安全  

23、面向对象的特征有哪些方面？  
封装：在面向对象语言中，我们操作的是一个又一个对象。这些对象的数据与操作数据方法会被封装到特定的类里面，我们在使用的时候不需要关心该对象的某些方法是如何实现的，只需要调用类提供的接口即可使用这些方法。这就是封装的含义。  
继承：当一个类是另一个类的特例时，我们可以让这个特例的类去继承另一个类，这样这个特例的类被称作子类，而继承的类被称作父类。这样子类不仅能有父类的特性，还可有自己的额外扩展，这就是继承的含义。  
多态：多态的含义可以表达为“对外提供一个接口，内部可以有多种实现”  

24、String 是最基本的数据类型吗？  
不是。Java 中的基本数据类型只有 8 个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type），剩下的都是引用类型（referencetype），Java 5 以后引入的枚举类型也算是一种比较特殊的引用类型。  

25、&和&&的区别？  
&运算符有两种用法：(1)按位与；(2)逻辑与。&&运算符是短路与运算。逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true 整个表达式的值才是 true。&&之所以称为短路运算是因为，如果&&左边的表达式的值是 false，右边的表达式会被直接短路掉，不会进行运算。很多时候我们可能都需要用&&而不是&，例如在验证用户登录时判定用户名不是 null 而且不是空字符串，应当写为：username != null &&!username.equals(“”)，二者的顺序不能交换，更不能用&运算符，因为第一个条件如果不成立，根本不能进行字符串的 equals 比较，否则会产生NullPointerException 异常。注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。  

26、用最有效率的方法计算 2 乘以 8？  
2 << 3（左移 3 位相当于乘以 2 的 3 次方，右移 3 位相当于除以 2 的 3 次方）。  

27、数组有没有 length()方法？String 有没有 length()方法？  
数组没有 length()方法，有 length 的属性。String 有 length()方法JavaScript中，获得字符串的长度是通过 length 属性得到的，这一点容易和 Java 混淆。  

28、构造器（constructor）是否可被重写（override）？  
构造器不能被继承，因此不能被重写，但可以被重载。  

29、是否可以继承 String 类？  
String 类是 final 类，不可以被继承。  

30、String 和 StringBuilder、StringBuffer 的区别？  
Java 平台提供了两种类型的字符串：String 和 StringBuffer/StringBuilder，它们可以储存和操作字符串。其中 String 是只读字符串，也就意味着 String 引用的字符串内容是不能被改变的。而 StringBuffer/StringBuilder 类表示的字符串对象可以直接进行修改。StringBuilder 是 Java 5 中引入的，它和 StringBuffer 的方法完全相同，区别在于它是在单线程环境下使用的，因为它的所有方面都没有被synchronized 修饰，因此它的效率也比 StringBuffer 要高。  

31、抽象类（abstract class）和接口（interface）有什么异同？  
抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。一个类如果继承了某个抽象类或者实现了某个接口都需要对其中的抽象方法全部进行实现，否则该类仍然需要被声明为抽象类。接口比抽象类更加抽象，因为抽象类中可以定义构造器，可以有抽象方法和具体方法，而接口中不能定义构造器而且其中的方法全部都是抽象方法。抽象类中的成员可以是 private、默认、protected、public 的，而接口中的成员全都是 public 的。抽象类中可以定义成员变量，而接口中定义的成员变量实际上都是常量。有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法。  

32、抽象的（abstract）方法是否可同时是静态的（static）,是否可同时是本地方法（native），是否可同时被 synchronized修饰？  
都不能。抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。本地方法是由本地代码（如 C 代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。synchronized 和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。  

33、阐述静态变量和实例变量的区别。  
静态变量是被 static 修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。静态变量可以实现让多个对象共享内存。  

34、String s = new String(“xyz”);创建了几个字符串对象？  
两个对象，一个是静态区的”xyz”，一个是用 new 创建在堆上的对象。  

35、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concreteclass）？  
接口可以继承接口，而且支持多重继承。抽象类可以实现(implements)接口，抽象类可继承具体类也可以继承抽象类。  

36、一个”.java”源文件中是否可以包含多个类（不是内部类）？有什么限制？  
可以，但一个源文件中最多只能有一个公开类（public class）而且文件名必须和公开类的类名完全保持一致。  

37、Java 中的 final 关键字有哪些用法？  
(1)修饰类：表示该类不能被继承；(2)修饰方法：表示方法不能被重写；(3)修饰变量：表示变量只能一次赋值以后值不能被修改（常量）。  

38、数据类型之间的转换？  
如何将字符串转换为基本数据类型？  
如何将基本数据类型转换为字符串？  
调用基本数据类型对应的包装类中的方法 parseXXX(String)或valueOf(String)即可返回相应基本类型；  
一种方法是将基本数据类型与空字符串（”“）连接（+）即可获得其所对应的字符串；另一种方法是调用 String 类中的 valueOf()方法返回相应字符串  

39、Error 和 Exception 有什么区别？  
Error 表示系统级的错误和程序不必处理的异常，是恢复不是不可能但很困难的情况下一种严重问题；比如内存溢出，不可能指望程序能处理这样的情况；Exception 表示需要捕捉或者需要程序进行处理的异常，是一种设计或实现问题；也就是说，它表示如果程序运行正常，从不会发生的情况。  

40、列出一些你常见的运行时异常？  
ArithmeticException（算术异常）
ClassCastException （类转换异常）
IllegalArgumentException （非法参数异常）
IndexOutOfBoundsException （下标越界异常）
NullPointerException （空指针异常）
SecurityException （安全异常）  

41、List、Set、Map 是否继承自 Collection 接口？  
List、Set 是，Map 不是。Map 是键值对映射容器，与 List 和 Set 有明显的区别，而 Set 存储的零散的元素且不允许有重复元素（数学中的集合也是如此），List是线性结构的容器，适用于按数值索引访问元素的情形。  

42、Collection 和 Collections 的区别？  
Collection 是一个接口，它是 Set、List 等容器的父接口；Collections 是个一工具类，提供了一系列的静态方法来辅助容器操作，这些方法包括对容器的搜索、排序、线程安全化等等。  

43、List、Map、Set 三个接口存取元素时，各有什么特点？  
List 以特定索引来存取元素，可以有重复元素。Set 不能存放重复元素（用对象equals()方法来区分元素是否重复）。Map 保存键值对（key-value pair）映射，映射关系可以是一对一或多对一。Set 和 Map 容器都有基于哈希存储和排序树的两种实现版本，基于哈希存储的版本理论存取时间复杂度为 O(1)，而基于排序树版本的实现在插入或删除元素时会按照元素或元素的键（key）构成排序树从而达到排序和去重的效果。  

44、启动一个线程是调用 run()还是 start()方法？  
启动一个线程是调用 start()方法，使线程所代表的虚拟处理机处于可运行状态，这意味着它可以由 JVM 调度并执行，这并不意味着线程就会立即运行。run()方法是线程启动后要进行回调（callback）的方法。  

45、Java 中有几种类型的流？  
字节流和字符流。字节流继承于 InputStream、OutputStream，字符流继承于Reader、Writer。在 java.io 包中还有许多其他的流，主要是为了提高性能和使用方便。关于 Java 的 I/O 需要注意的有两点：一是两种对称性（输入和输出的对称性，字节和字符的对称性）；二是两种设计模式（适配器模式和装潢模式）。另外 Java 中的流不同于 C#的是它只有一个维度一个方向。  

46、简述正则表达式及其用途?  
在编写处理字符串的程序时，经常会有查找符合某些复杂规则的字符串的需要。正则表达式就是用于描述这些规则的工具。换句话说，正则表达式就是记录文本规则的代码。  

47、Java 中能创建 volatile 数组吗？  
能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。我的意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。  

48、怎么将 byte 转换为 String？  
可以使用 String 接收 byte[] 参数的构造器来进行转换，需要注意的点是要使用的正确的编码，否则会使用平台默认编码，这个编码可能跟原来的编码相同，也可能不同。  

49、a = a + b 与 a += b 的区别？  
+= 隐式的将加操作的结果类型强制转换为持有结果的类型。如果两这个整型相加，如 byte、short 或者 int，首先会将它们提升到 int 类型，然后在执行加法操作。如果加法操作的结果比 a 的最大值要大，则 a+b 会出现编译错误，但是a += b 没问题。例如：  
byte a =127;  
byte b =127;  
b = a + b;//error:cannot convert from int to byte  
b += a;//ok  

50、3*0.1 == 0.3 将会返回什么？true 还是 false？  
false，因为有些浮点数不能完全精确的表示出来。  

51、JRE、JDK、JVM 及 JIT 之间有什么不同？  
JRE 代表 Java 运行时（Java run-time），是运行 Java 引用所必须的。JDK 代表 Java 开发工具（Java development kit），是 Java 程序的开发工具，如 Java编译器，它也包含 JRE。JVM 代表 Java 虚拟机（Java virtual machine），它的责任是运行 Java 应用。JIT 代表即时编译（Just In Time compilation），当代码执行的次数超过一定的阈值时，会将 Java 字节码转换为本地代码，如，主要的热点代码会被准换为本地代码，这样有利大幅度提高 Java 应用的性能。  

52、a双等于b和a.equals(b)有什么区别？  
如果 a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。  

53、final、finalize 和 finally 的不同之处？  
final 是一个修饰符，可以修饰变量、方法和类。如果 final 修饰变量，意味着该变量的值在初始化后不能被改变。finalize 方法是在对象被回收之前调用的方法，给对象自己最后一个复活的机会，但是什么时候调用 finalize 没有保证。finally是一个关键字，与 try 和 catch 一起用于异常的处理。finally 块一定会被执行，无论在 try 块中是否有发生异常。  

54、List、Set、Map 和 Queue 之间的区别？  
List 是一个有序集合，允许元素重复。它的某些实现可以提供基于下标值的常量访问时间，但是这不是 List 接口保证的。Set 是一个无序集合。  

55、poll() 方法和 remove() 方法的区别？  
poll() 和 remove() 都是从队列中取出一个元素，但是 poll() 在获取元素失败的时候会返回空，但是 remove() 失败的时候会抛出异常。  

56、ArrayList 与 LinkedList 的不区别？  
最明显的区别是 ArrrayList 底层的数据结构是数组，支持随机访问，而LinkedList 的底层数据结构书链表，不支持随机访问。使用下标访问一个元素，ArrayList 的时间复杂度是 O(1)，而 LinkedList 是 O(n)。  

57、用哪两种方式来实现集合的排序？  
你可以使用有序集合，如 TreeSet 或 TreeMap，你也可以使用有顺序的的集合，如 list，然后通过 Collections.sort() 来排序。  

58、Java 中的 TreeMap 是采用什么树实现的？  
Java 中的 TreeMap 是使用红黑树实现的。  

59、有没有可能两个不相等的对象有有相同的 hashcode？  
有可能，两个不相等的对象可能会有相同的 hashcode 值，这就是为什么在hashmap 中会有冲突。相等 hashcode 值的规定只是说如果两个对象相等，必须有相同的 hashcode 值，但是没有关于不相等对象的任何规定。  

60、Java 中，Comparator 与 Comparable 有什么不同？  
Comparable 接口用于定义对象的自然顺序，而 comparator 通常用于定义用户定制的顺序。Comparable 总是只有一个，但是可以有多个 comparator 来定义对象的顺序。  

61、Java 中怎么创建 ByteBuffer？  
byte[] bytes = new byte[10];  
ByteBuffer buf = ByteBuffer.wrap(bytes);  

62、、说出几点 Java 中使用 Collections 的最佳实践？  
a）使用正确的集合类，例如，如果不需要同步列表，使用 ArrayList 而不Vector。  
b）优先使用并发集合，而不是对集合进行同步。并发集合提供更好的可扩展性。  
c）使用接口代表和访问集合，如使用 List 存储 ArrayList，使用 Map 存储HashMap 等等。  
d）使用迭代器来循环集合。  
e）使用集合的时候使用泛型。  

63、Java 中，抽象类与接口之间有什么不同？  
Java 中，抽象类和接口有很多不同之处，但是最重要的一个是 Java 中限制一个类只能继承一个类，但是可以实现多个接口。抽象类可以很好的定义一个家族类的默认行为，而接口能更好的定义类型，有助于后面实现多态机制。   

64、适配器模式是什么？什么时候使用？  
适配器模式提供对接口的转换。如果你的客户端使用某些接口，但是你有另外一些接口，你就可以写一个适配去来连接这些接口。  

65、什么是“依赖注入”和“控制反转”？为什么有人使用？  
控制反转（IOC）是 Spring 框架的核心思想，用我自己的话说，就是你要做一件事，别自己可劲 new 了，你就说你要干啥，然后外包出去就好~依赖注入（DI） 在我浅薄的想法中，就是通过接口的引用和构造方法的表达，将一些事情整好了反过来传给需要用到的地方~  

66、抽象类是什么？它与接口有什么区别？你为什么要使用过抽象类？  
接口用于规范，抽象类用于共性.声明方法的存在而不去实现它的类被叫做抽象类接口（interface）是抽象类的变体。在接口中，所有方法都是抽象的。  

67、构造器注入和 setter 依赖注入，那种方式更好？  
每种方式都有它的缺点和优点。构造器注入保证所有的注入都被初始化，但是setter 注入提供更好的灵活性来设置可选依赖。如果使用 XML 来描述依赖，Setter 注入的可读写会更强。经验法则是强制依赖使用构造器注入，可选依赖使用 setter 注入。  

68、依赖注入和工程模式之间有什么不同？  
虽然两种模式都是将对象的创建从应用的逻辑中分离，但是依赖注入比工程模式更清晰。通过依赖注入，你的类就是 POJO，它只知道依赖而不关心它们怎么获取。使用工厂模式，你的类需要通过工厂来获取依赖。因此，使用 DI 会比使用工厂模式更容易测试。  

69、适配器模式和装饰器模式有什么区别？  
虽然适配器模式和装饰器模式的结构类似，但是每种模式的出现意图不同。适配器模式被用于桥接两个接口，而装饰模式的目的是在不修改类的情况下给类增加新的功能。  

70、适配器模式和代理模式之前有什么不同？  
这个问题与前面的类似，适配器模式和代理模式的区别在于他们的意图不同。由于适配器模式和代理模式都是封装真正执行动作的类，因此结构是一致的，但是适配器模式用于接口之间的转换，而代理模式则是增加一个额外的中间层，以便支持分配、控制或智能访问。  

71、什么是模板方法模式？  
模板方法提供算法的框架，你可以自己去配置或定义步骤。例如，你可以将排序算法看做是一个模板。它定义了排序的步骤，但是具体的比较，可以使用Comparable 或者其语言中类似东西，具体策略由你去配置。列出算法概要的方法就是众所周知的模板方法。  

72、继承和组合之间有什么不同？  
虽然两种都可以实现代码复用，但是组合比继承共灵活，因为组合允许你在运行时选择不同的实现。用组合实现的代码也比继承测试起来更加简单。  

73、描述 Java 中的重载和重写？  
重载和重写都允许你用相同的名称来实现不同的功能，但是重载是编译时活动，而重写是运行时活动。你可以在同一个类中重载方法，但是只能在子类中重写方法。重写必须要有继承。  

74、Java 中，throw 和 throws 有什么区别？  
throw 用于抛出 java.lang.Throwable 类的一个实例化对象，意思是说你可以通过关键字 throw 抛出一个 Error 或者 一个 Exception，如：throw new IllegalArgumentException(“size must be multiple of 2″ )而 throws 的作用是作为方法声明和签名的一部分，方法被抛出相应的异常以便调用者能处理。Java 中，任何未处理的受检查异常强制在 throws 子句中声明。  

75、说出 5 个 JDK 1.8 引入的新特性？  
Java 8 在 Java 历史上是一个开创新的版本，下面 JDK 8 中 5 个主要的特性：  
Lambda 表达式，允许像对象一样传递匿名函数  
Stream API，充分利用现代多核 CPU，可以写出很简洁的代码  
Date 与 Time API，最终，有一个稳定、简单的日期和时间库可供你使用  
扩展方法，现在，接口中可以有静态、默认方法。  
重复注解，现在你可以将相同的注解在同一类型上使用多次。  



### Java用心学习就很好玩

前几天和朋友约好出去，让他在公交车站牌那里等我。等我开车去公交车站牌那里他人不见了，我打电话问他人哪去了?他说：我在公交车站牌这里啊。我说：这里没人啊，你到底在哪?他说：我也不知道我在哪，人家把公交车站牌挖走了我跟在他后面一起走的
